<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>example.com</title>
	</head>
	<body>
		<h1>Example of saving a stream directly to the filesystem</h1>
		<form id="$form">
			<h3>What would you like to save?</h3>
			<label><input name="kind" value="text" type="radio" checked>Plain text (Save as you type)</label><br>
			<label><input name="kind" value="video" type="radio">Video stream</label><br>
			<label><input name="kind" value="audio" type="radio">Audio stream</label><br>
			<!-- disabled until now, haven't had the time to write any demo using fetch -->
			<label><input name="kind" value="fetch" type="radio">Fetch stream</label>
			 - kind of cheesy, since you can use fetchEvent to add
			 Content-Disposition header (but requires service worker + ssl)<br>
			<label><input name="kind" value="screen" type="radio">Screen stream</label>
			- requires chromes <a href="https://goo.gl/5La0Iz">Screen Capturing</a> extension<br><br>
			<label>What should the name of the file be?<br>
				<input name="$filename" required value="sample.txt">
			</label>
			<input type="submit" value="Start">
		</form>
		<div id="$writer" hidden>
			<button id="$a">Write some aaa's</button>
			<button id="$b">Write some bbb's</button>
			<button id="$c">Write some ccc's</button>
		</div>
		<button id="$close" hidden>close stream</button>
		<script src="https://rawgit.com/jimmywarting/browser-su/master/build/permissions.js"></script>
		<script src="https://wzrd.in/standalone/web-streams-polyfill@latest"></script>
		<script src="StreamSaver.js"></script>
		<script>
			$form.onsubmit = event => {
				event.preventDefault()

				let
				kind = $form.querySelector(':checked').value,
				filename = $form.$filename.value,
				permission,
				url = "https://d8d913s460fub.cloudfront.net/videoserver/cat-test-video-320x240.mp4",
				myFile = fs.createWriteStream(filename)

				$form.remove()
				$close.hidden = false
				$close.onclick = event => myFile.close()

				switch (kind) {
					case "text":
						$writer.hidden = false
						let encoder = new TextEncoder

						let data = "a".repeat(1024)
						let uint8array = encoder.encode(data + "\n\n")
						myFile.write(uint8array) // Write some data to triger saving

						$a.onclick = $b.onclick = $c.onclick = event => {
							let data = event.target.id[1].repeat(1024)
							let uint8array = encoder.encode(data + "\n\n")
							myFile.write(uint8array)
						}
					break; case "video":
						permission = {name: 'userMedia', video: true}
					break; case "audio":
						permission = {name: 'userMedia', audio: true}
					break; case "screen":
						permission = {name: 'screen'}
					break;
					case "file":
					case "blob":

						var blob = new Blob([
							"a".repeat(1024),
							"b".repeat(1024),
							"c".repeat(1024)
						])

						let stream = fs.createBlobReader(blob)
						stream.pipeTo(myFile)

						// This is rather quite simple with fetch
						// cuz you can retrive an actual stream with it
						// Create a object url that you can request
						// then just fall into next "fetch case"
						url = URL.createObjectURL(blobOrFile)

						// If you would like to see an other method
						// that dosn't use ajax but uses FileReader instead
						// look in the ./util.js
					case "fetch":
						// Here we could just simply open the link and then let
						// the SW add Content-Disposition header to that request.
						fetch(url).then(res => {
							// https://jakearchibald.com/2016/streams-ftw/
							// The body is a stream :)
							console.log(res.body)
							let reader = res.body.getReader()
							let pump = () => {
								return reader.read().then(({ value, done }) => {
									if (done) {
										myFile.close()
										return
									}
									myFile.write(value)
									return pump()
								})
							}
							pump()
						})
					break;
				}

				permission && su.request(permission).then(stream => {
					let fr = new FileReader
					let mediaRecorder = new MediaRecorder(stream)
					let chunks = Promise.resolve()

					mediaRecorder.start()
					$close.onclick = event => {
						stopStream(stream)
						mediaRecorder.stop()
						setTimeout(()=>{
							chunks.then(evt => {
								myFile.close()
							})
						}, 1000)
					}
					mediaRecorder.ondataavailable = evt => {
						let blob = evt.data

						chunks = chunks.then(() => new Promise(resolve => {
							fr.onload = () => {
								// Should we let the serviceWorker be able to accept
								// anything other then uint8array? ReadableStream don't seems
								// so happy with anything else... but could load of some work
								// of the main thread +1
								let uint8array = new Uint8Array(fr.result)
								myFile.write(uint8array)
								resolve()
							}
							fr.readAsArrayBuffer(blob)
						}))
					}

				})
			}


			function stopStream (stream) {
				let tracks = [
					...stream.getAudioTracks(),
					...stream.getVideoTracks()
				]

				for(let track of tracks)
					track.stop()
			}
		</script>
	</body>
</html>
