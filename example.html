<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>example.com</title>
	</head>
	<body>
		<h1>Example of saving a stream directly to the filesystem</h1>
		<form id="$form">
			<h3>What would you like to save?</h3>
			<label><input name="kind" value="text" type="radio" checked>Plain text (Save as you type)</label><br>
			<label><input name="kind" value="video" type="radio">Video stream</label><br>
			<label><input name="kind" value="audio" type="radio">Audio stream</label><br>
			<!-- disabled until now, haven't had the time to write any demo using fetch -->
			<label><input name="kind" value="fetch" type="radio">Fetch stream</label>
			 - kind of cheesy, since you can use fetchEvent to add
			 Content-Disposition header (but requires service worker + ssl)<br>
			<label><input name="kind" value="screen" type="radio">Screen stream</label>
			- requires chromes <a href="https://goo.gl/5La0Iz">Screen Capturing</a> extension<br><br>
			<label>What should the name of the file be?<br>
				<input name="$filename" required value="sample.txt">
			</label>
			<input type="submit" value="Start">
		</form>
		<div id="$writer" hidden>
			<button id="$a">Write some aaa's</button>
			<button id="$b">Write some bbb's</button>
			<button id="$c">Write some ccc's</button>
		</div>
		<button id="$close" hidden>close stream</button>
		<script src="https://rawgit.com/jimmywarting/browser-su/master/build/permissions.js"></script>
		<script src="StreamSaver.js"></script>
		<script>
			$form.onsubmit = event => {
				event.preventDefault()

				let
				kind = $form.querySelector(':checked').value,
				filename = $form.$filename.value,
				permission,
				url = "https://d8d913s460fub.cloudfront.net/videoserver/cat-test-video-320x240.mp4"

				$form.remove()

				switch (kind) {
					case "text":
						$writer.hidden = false
						let encoder = new TextEncoder
						let stream = new ReadableStream({
							start(controller) {
								let data = "a".repeat(1024)
								let uint8array = encoder.encode(data + "\n\n")
								controller.enqueue(uint8array)

								$close.hidden = false
								$close.onclick = () => controller.close()

								$a.onclick = $b.onclick = $c.onclick = event => {
									let data = event.target.id[1].repeat(1024)
									let uint8array = encoder.encode(data + "\n\n")
									controller.enqueue(uint8array)
								}
							},
							cancel() {
								console.log("user aborted")
							}
						})

						saveStream(stream, filename)
					break; case "video":
						permission = {name: 'userMedia', video: true}
					break; case "audio":
						permission = {name: 'userMedia', audio: true}
					break; case "screen":
						permission = {name: 'screen'}
					break;
					case "file":
					case "blob":
						// This is rather quite simple with fetch
						// cuz you can retrive an actual stream with it
						// Create a object url that you can request
						// then just fall into next "fetch case"
						url = URL.createObjectURL(blobOrFile)

						// If you would like to see an other method
						// that dosn't use ajax but uses FileReader instead
						// look in the ./util.js
					case "fetch":
						// Here we could just simply open the link and then let
						// the SW add Content-Disposition header to that request.
						fetch(url).then(res => {
							// https://jakearchibald.com/2016/streams-ftw/
							// The body is a stream :)
							saveStream(res.body, filename)
						})
					break;
				}

				permission && su.request(permission).then(stream => {
					// Haven't decided yet on the api
					saveStream(stream, filename)
					$close.hidden = false
					$close.onclick = () => stopStream(stream)
				})
			}


			function stopStream (stream) {
				let tracks = [
					...stream.getAudioTracks(),
					...stream.getVideoTracks()
				]

				for(let track of tracks)
					track.stop()
			}
		</script>
	</body>
</html>
